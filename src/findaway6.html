<html doctype="html5">

<head>
</head>

<body>
  <div>
    <input style="width: 50px" type="number" value="127" id="threshold" name="threshold" />
    <input style="width: 50px" type="number" value="127" id="stepsize" name="stepsize" />
    <label for="scale">scale</label><input style="width: 50px" type="number" value="16" id="scale" name="scale" />
    <input type="file" accept="image/*" name="image" id="file" onchange="loadFile(event)" style="display: none;">
    <label for="file" style="cursor: pointer;">Upload Image</label>
    <img id="output" width="604" height="386" />
    <canvas id="canvas" width="604" height="386"></canvas>
    <svg id="svg1" style="background-color:#fff; stroke-linecap:round; stroke-linejoin:round; stroke-width:1;"
      width="604" height="386" xmlns="http://www.w3.org/2000/svg">
      <g id="0-registration" inkscape:label="0-registration" inkscape:groupmode="layer" stroke="black" fill="none">
        <path d="M0.5 0.5 L603.5 0.5 L603.5 385.5 L0.5 385.5 L0.5 0.5" />
      </g>
      <g id="1-yellow" inkscape:label="1-yellow" inkscape:groupmode="layer" stroke="yellow" fill="none"
        style="mix-blend-mode: multiply">
      </g>
      <g id="2-magenta" inkscape:label="2-magenta" inkscape:groupmode="layer" stroke="magenta" fill="none"
        style="mix-blend-mode: multiply">
      </g>
      <g id="3-cyan" inkscape:label="3-cyan" inkscape:groupmode="layer" stroke="cyan" fill="none"
        style="mix-blend-mode: multiply">
      </g>
    </svg>
    <button id='download-svg'>download svg</button>
  </div>
</body>
<script>

  let pos = [0, 0];
  let dpos = [1, 0];
  let penDown = false
  const xLines = 73 // given a physical pen width and a miniKit 2 axidraw plotter
  const yLines = 45 // given a physical pen width and a miniKit 2 axidraw plotter
  // const xLines = 73 * 2
  // const yLines = 45 * 2

  let width = 0 // get from image size once loaded
  let height = 0
  // since images are stored as a 1D array of R G B Alpha we get the index of a pixel at (x,y)
  const getIndex = (x, y) => (y * width + x) * 4;
  let svgGroup = []
  svgGroup[2] = document.getElementById('1-yellow')
  svgGroup[1] = document.getElementById('2-magenta')
  svgGroup[0] = document.getElementById('3-cyan')

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let fileName = ''
  let scale = 1

  const image = new Image();
  var loadFile = function (event) {
    image.src = URL.createObjectURL(event.target.files[0]);
    var imageEle = document.getElementById('output');
    imageEle.src = URL.createObjectURL(event.target.files[0]);
    // console.log(event.target.files[0])
    fileName = event.target.files[0].name.slice(0, event.target.files[0].name.indexOf('.'))
    console.log(fileName)
  };
  image.onload = () => {
    const stepsize = parseInt(document.getElementById('stepsize').value, 10)
    let threshold = parseInt(document.getElementById('threshold').value, 10)
    //scale = parseInt(document.getElementById('scale').value, 10)
    scale = Math.floor((image.width / xLines))
    console.log("scale", scale, scale / 4)
    const svgEle = document.getElementById('svg1')
    svgEle.setAttribute("style", `background-color:#fff; stroke-linecap:round; stroke-linejoin:round; stroke-width:${xLines / 604 * 8};`)
    const sw = image.width
    const sh = image.height
    width = sw
    height = sh
    canvas.width = sw
    canvas.height = sh
    // size for the miniKit2 width="604" height="386"
    ctx.drawImage(image, 0, 0, sw, sh)

    const imageData = ctx.getImageData(0, 0, sw, sh);
    floydSteinbergDithering(imageData, width, height)
    for (let s = 0; s < scale; s++) {
      findaway(imageData, threshold, stepsize, 0, scale, 0+s, 0+s)
      findaway(imageData, threshold, stepsize, 1, scale, 2+s, 1+s)
      findaway(imageData, threshold, stepsize, 2, scale, 1+s, 4+s)
      threshold -= stepsize
      // findaway(imageData, threshold, stepsize, 0, scale, 3, 3)
      // findaway(imageData, threshold, stepsize, 1, scale, 4, 5)
      // findaway(imageData, threshold, stepsize, 2, scale, 5, 2)
    }
    //floydSteinbergDithering(imageData, sw, sh);
    ctx.putImageData(imageData, 0, 0);
  };
  
  let linePts = []
  const lineInit = (x1, y1) => {
    linePts = []
    linePts.push([x1, y1])
  }

  const lineExtend = (x2, y2) => {
    if (linePts.length < 2) {
      lineCorner(x2, x2)
    }
    linePts[linePts.length - 1] = [x2, y2]
  }

  const lineCorner = (x2, y2) => {
    linePts.push([x2, y2])
  }

  const toSvgLineStr = (pt) => (`L${pt[0]} ${pt[1]}`)

  const lineComplete = (group) => {
    if (linePts.length < 2) return
    let line = document.createElementNS('http://www.w3.org/2000/svg', 'path')
    const firstPt = linePts.shift()
    line.setAttribute('d', `M${firstPt[0]} ${firstPt[1]} ${linePts.map(toSvgLineStr)}`);
    group.appendChild(line);
    linePts = []
  }

  const downloadSVG = () => {
    // since React will not do namespaced attributes (e.g. inkscape:label="0-Yellow"), so....
    svg = document.getElementsByTagName("svg")[0];
    svg.setAttribute("xmlns:inkscape", "http://www.inkscape.org/namespaces/inkscape");

    const svgtext = svg.outerHTML;
    if (svgtext) {
      const blob = new Blob([svgtext], { type: "image/svg+xml" });
      downloadBlob(blob, `findaway06_${fileName}.svg`);
    }
  };

  function downloadBlob(blob, filename) {
    const objectUrl = URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.href = objectUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    setTimeout(() => URL.revokeObjectURL(objectUrl), 5000);
  }

  document.getElementById("download-svg").addEventListener("click", downloadSVG);

  const findFirst = (imArr, threshold, channel, xoff, yoff) => {
    let randomTries = 20
    while (randomTries) {
      randomTries--
      const x = Math.floor(Math.random() * (width - xoff) / scale) * scale
      const y = Math.floor(Math.random() * (height - yoff) / scale) * scale
      const i = getIndex(x + xoff, y + yoff)
      // console.log(i, x, y, channel, imArr.data[i + channel])
      if (imArr.data[i + channel] <= threshold) {
        return [x + xoff, y + yoff]
      }
    }
    // console.log("findFirst failed random")
    for (x = 0; x < width - xoff; x += scale) {
      for (y = 0; y < height - yoff; y += scale) {
        const i = getIndex(x + xoff, y + yoff)
        // if(x === 50 && y === 60) console.log("", i, x, y, channel)
        if (imArr.data[i + channel] <= threshold)
          return [x + xoff, y + yoff]
      }
    }
    // console.log("findFirst failed exaustive")
    return [-1, -1];
  }
  const inBounds = (x, y) => (x > 0 && y > 0 && x < width && y < height)
  const alterHoriz2 = () => {
    if (dpos[0] > 0 || dpos[0] < 0) {
      dpos[0] = 0
      dpos[1] = (Math.random() > 0.5) ? 1 : -1;
      return
    }
    if (dpos[1] > 0 || dpos[1] < 0) {
      dpos[0] = (Math.random() > 0.5) ? 1 : -1;
      dpos[1] = 0
      return
    }
    dpos[0] = 0;
    dpos[1] = (Math.random() > 0.5) ? 1 : -1;
  }
  const alterHoriz = () => {
    if (dpos[0] > 0) {
      dpos[0] = 0
      dpos[1] = 1
      return
    }
    if (dpos[0] < 0) {
      dpos[0] = 0
      dpos[1] = -1
      return
    }
    if (dpos[1] > 0) {
      dpos[1] = 0
      dpos[0] = -1
      return
    }
    if (dpos[1] < 0) {
      dpos[1] = 0
      dpos[0] = 1
      return
    }
  }

  const findNext = (imArr, threshold, channel, xoff, yoff) => {
    let ableToFlow = 0
    while (ableToFlow < 12) {
      ableToFlow++
      let mpx = pos[0] + dpos[0] * scale + xoff
      let mpy = pos[1] + dpos[1] * scale + yoff
      const i = getIndex(mpx, mpy)
      if (inBounds(mpx, mpy) && imArr.data[i + channel] <= threshold) {
        return [mpx, mpy, (ableToFlow === 1)]
      }
      alterHoriz2()
    }

    let neighbors = 0
    let lastX = 0
    let lastY = 0
    for (x = pos[0] - 1; x < pos[0] + 1; x += scale) {
      for (y = pos[1] - 1; y < pos[1] + 1; y += scale) {
        if (inBounds(x + xoff, y + yoff)) {
          const i = getIndex(x + xoff, y + yoff)
          if (imArr[i + channel] <= threshold) {
            neighbors++
            lastX = x + xoff
            lastY = y + yoff
          }
        }
      }
    }
    if (neighbors >= 1) return [lastX, lastY, false]
    penDown = false
    return [-1, -1, false]
  }

  const findaway = (imArr, threshold, stepsize, channel, scale, xoff, yoff) => {
    penDown = false
    keepGoing = true
    let rounds = 1000000
    while (keepGoing && rounds > 0) {
      rounds--
      if (penDown) {
        const [nx, ny, flow] = findNext(imArr, threshold, channel, 0, 0)
        if (nx < 0 || ny < 0) {
          lineComplete(svgGroup[channel])
          penDown = false
          // console.log("line done at", pos)
          continue
        }
        if (flow) {
          lineExtend(nx / scale * 8 + xoff, ny / scale * 8 + yoff)
        }
        else {
          lineCorner(nx / scale * 8 + xoff, ny / scale * 8 + yoff)
        }
        const i = getIndex(pos[0], pos[1])
        imArr.data[i + channel] = Math.min(255, imArr.data[i + channel] + stepsize)
        pos[0] = nx //  - xoff
        pos[1] = ny // - yoff
      }
      else {
        const [fx, fy] = findFirst(imArr, threshold, channel, 0, 0)
        if (fx < 0 || fy < 0) {
          keepGoing = false
          break
        }
        lineInit(fx / scale * 8 + xoff, fy / scale * 8 + yoff)
        const i = getIndex(fx, fy)
        imArr.data[i + channel] = Math.min(255, imArr.data[i + channel] + stepsize)
        pos[0] = fx // - xoff
        pos[1] = fy // - yoff
        penDown = true
      }
    }
    console.log("unused rounds", rounds)
  }


  // Function to draw a rotated rectangle with anti-aliasing
  function drawRotatedRectangle(x, y, width, length, angle) {
    // Convert angle to radians
    const radians = (Math.PI / 180) * angle;

    // Set anti-aliasing
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    // Save the current transformation matrix
    ctx.save();

    // Translate to the center of the rectangle
    ctx.translate(x + width / 2, y + width / 2);

    // Rotate the rectangle
    ctx.rotate(radians);

    // Draw the rectangle
    ctx.fillStyle = "rgba(0, 0, 255, 0.2)";
    ctx.fillRect(-width / 2, -width / 2, length, width);

    // Restore the transformation matrix to its original state
    ctx.restore();
  }

  // Function to draw a rotated line with anti-aliasing
  function drawRotatedLine(x, y, width, length, angle) {
    // Convert angle to radians
    const radians = (Math.PI / 180) * angle;

    // Set anti-aliasing
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    ctx.strokeStyle = "rgba(0, 0, 255, 0.3)";
    ctx.moveTo(x, y)
    ctx.lineTo(x + Math.cos(radians) * length, y + Math.sin(radians) * length)
    ctx.lineWidth = width
    ctx.stroke()
  }




  function floydSteinbergDithering(imageData, width, height) {
    const imageDataCopy = new ImageData(new Uint8ClampedArray(imageData.data), width, height);
    const ditherScale = 1 // scale
    for (let y = 0; y < height; y += ditherScale) {
      for (let x = 0; x < width; x += ditherScale) {
        const index = getIndex(x, y)
        const oldR = imageDataCopy.data[index];
        const oldG = imageDataCopy.data[index + 1];
        const oldB = imageDataCopy.data[index + 2];

        // Find the closest color (0 or 255) for each channel
        const newR = oldR > 128 ? 255 : 0;
        const newG = oldG > 128 ? 255 : 0;
        const newB = oldB > 128 ? 255 : 0;

        // Set the new color
        imageData.data[index] = newR;
        imageData.data[index + 1] = newG;
        imageData.data[index + 2] = newB;
        // Calculate the error
        const errorR = oldR - newR;
        const errorG = oldG - newG;
        const errorB = oldB - newB;

        // Distribute the error to neighboring pixels
        if (x + 1 < width) {
          distributeError(imageDataCopy, width, x + 1, y, errorR, errorG, errorB, 7 / 16);
        }
        if (x - 1 >= 0 && y + 1 < height) {
          distributeError(imageDataCopy, width, x - 1, y + 1, errorR, errorG, errorB, 3 / 16);
        }
        if (y + 1 < height) {
          distributeError(imageDataCopy, width, x, y + 1, errorR, errorG, errorB, 5 / 16);
        }
        if (x + 1 < width && y + 1 < height) {
          distributeError(imageDataCopy, width, x + 1, y + 1, errorR, errorG, errorB, 1 / 16);
        }
      }
    }
  }
  function distributeError(imageData, width, x, y, errorR, errorG, errorB, factor) {
    const index = (y * width + x) * 4;
    imageData.data[index] = Math.max(0, Math.min(255, imageData.data[index] + errorR * factor));
    imageData.data[index + 1] = Math.max(0, Math.min(255, imageData.data[index + 1] + errorG * factor));
    imageData.data[index + 2] = Math.max(0, Math.min(255, imageData.data[index + 2] + errorB * factor));
  }

</script>

</html>