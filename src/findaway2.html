<html doctype="html5">

<head>
</head>

<body>
  <div>
    <input style="width: 50px" type="number" value="220" id="threshold" name="threshold" />
    <input style="width: 50px" type="number" value="110" id="stepsize" name="stepsize" />
    <label for="scale">scale</label><input style="width: 50px" type="number" value="4" id="scale" name="scale" />
    <input type="file" accept="image/*" name="image" id="file" onchange="loadFile(event)" style="display: none;">
    <label for="file" style="cursor: pointer;">Upload Image</label>
    <img id="output" width="604" height="386" />
    <canvas id="canvas" width="151" height="95.5"></canvas>
    <svg style="background-color:#fff; stroke-linecap:round; stroke-linejoin:round; stroke-width:1;" width="604"
      height="386" xmlns="http://www.w3.org/2000/svg">
      <g id="0-registration" inkscape:label="0-registration" inkscape:groupmode="layer" stroke="black" fill="none">
        <path d="M0.5 0.5 L603 0.5 L603 385 L0.5 385 L0.5 0.5" />
      </g>
      <g id="1-yellow" inkscape:label="1-yellow" inkscape:groupmode="layer" stroke="yellow" fill="none"
        style="mix-blend-mode: multiply">
      </g>
      <g id="2-magenta" inkscape:label="2-magenta" inkscape:groupmode="layer" stroke="magenta" fill="none"
        style="mix-blend-mode: multiply">
      </g>
      <g id="3-cyan" inkscape:label="3-cyan" inkscape:groupmode="layer" stroke="cyan" fill="none"
        style="mix-blend-mode: multiply">
      </g>
    </svg>
    <button id='download-svg'>download svg</button>
  </div>
</body>
<script>

  let pos = [0, 0];
  let dpos = [1, 0];
  let penDown = false
  const r = 5;
  let width = 0 // get from image size once loaded
  let height = 0
  const getIndex = (x, y) => (y * width + x) * 4;
  let svgGroup = []
  svgGroup[2] = document.getElementById('1-yellow')
  svgGroup[1] = document.getElementById('2-magenta')
  svgGroup[0] = document.getElementById('3-cyan')
  function floydSteinbergDithering(imageData, width, height) {
    const imageDataCopy = new ImageData(new Uint8ClampedArray(imageData.data), width, height);

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const index = getIndex(x, y)
        const oldR = imageDataCopy.data[index];
        const oldG = imageDataCopy.data[index + 1];
        const oldB = imageDataCopy.data[index + 2];

        // Find the closest color (0 or 255) for each channel
        const newR = oldR > 128 ? 255 : 0;
        const newG = oldG > 128 ? 255 : 0;
        const newB = oldB > 128 ? 255 : 0;

        // Set the new color
        imageData.data[index] = newR;
        imageData.data[index + 1] = newG;
        imageData.data[index + 2] = newB;
        if (!newR) {
          addDot(svgGroup[0], x * 4 + 2, y * 4 + 4, 1) // sqrcolor(512 - oldR) / 256)
        }
        if (!newG) {
          addDot(svgGroup[1], x * 4 + 2, y * 4 + 4, 1) // sqrcolor(512 - oldG) / 256)
        }
        if (!newB) {
          addDot(svgGroup[2], x * 4 + 2, y * 4 + 4, 1) // sqrcolor(512 - oldB) / 256)
        }

        // Calculate the error
        const errorR = oldR - newR;
        const errorG = oldG - newG;
        const errorB = oldB - newB;

        // Distribute the error to neighboring pixels
        if (x + 1 < width) {
          distributeError(imageDataCopy, width, x + 1, y, errorR, errorG, errorB, 7 / 16);
        }
        if (x - 1 >= 0 && y + 1 < height) {
          distributeError(imageDataCopy, width, x - 1, y + 1, errorR, errorG, errorB, 3 / 16);
        }
        if (y + 1 < height) {
          distributeError(imageDataCopy, width, x, y + 1, errorR, errorG, errorB, 5 / 16);
        }
        if (x + 1 < width && y + 1 < height) {
          distributeError(imageDataCopy, width, x + 1, y + 1, errorR, errorG, errorB, 1 / 16);
        }
      }
    }
  }
  const sqrcolor = (n) => {
    const norm = n / 512
    return (norm * norm * norm * norm) * 512
  }
  function distributeError(imageData, width, x, y, errorR, errorG, errorB, factor) {
    const index = (y * width + x) * 4;
    imageData.data[index] = Math.max(0, Math.min(255, imageData.data[index] + errorR * factor));
    imageData.data[index + 1] = Math.max(0, Math.min(255, imageData.data[index + 1] + errorG * factor));
    imageData.data[index + 2] = Math.max(0, Math.min(255, imageData.data[index + 2] + errorB * factor));
  }

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let fileName = ''

  const image = new Image();
  var loadFile = function (event) {
    image.src = URL.createObjectURL(event.target.files[0]);
    var imageEle = document.getElementById('output');
    imageEle.src = URL.createObjectURL(event.target.files[0]);
    // console.log(event.target.files[0])
    fileName = event.target.files[0].name.slice(0, event.target.files[0].name.indexOf('.'))
    console.log(fileName)
  };
  image.onload = () => {
    const stepsize = parseInt(document.getElementById('stepsize').value, 10)
    let threshold = parseInt(document.getElementById('threshold').value, 10)
    const scale = parseInt(document.getElementById('scale').value, 10)
    const sw = image.width
    const sh = image.height
    width = sw
    height = sh
    canvas.width = sw
    canvas.height = sh
    // size for the miniKit2 width="604" height="386"
    ctx.drawImage(image, 0, 0, sw, sh)

    const imageData = ctx.getImageData(0, 0, sw, sh);
    findaway(imageData, threshold, stepsize, 0, scale, 0, 0)
    findaway(imageData, threshold, stepsize, 1, scale, 2, 1)
    findaway(imageData, threshold, stepsize, 2, scale, 1, 4)
    threshold += stepsize
    findaway(imageData, threshold, stepsize, 0, scale, 3, 3)
    findaway(imageData, threshold, stepsize, 1, scale, 4, 5)
    findaway(imageData, threshold, stepsize, 2, scale, 5, 2)

    //floydSteinbergDithering(imageData, sw, sh);
    ctx.putImageData(imageData, 0, 0);
  };
  const addDot = (group, cx, cy, r) => {
    if (r === 0) return;
    let cir = document.createElementNS('http://www.w3.org/2000/svg', 'path')
    // cir.setAttribute('d', `M${cx - r} ${cy - r} L${cx + r} ${cy - r} L${cx + r} ${cy + r} L${cx - r} ${cy + r} L${cx - r} ${cy - r}`);
    cir.setAttribute('d', `M${cx} ${cy} L${cx + 0.01} ${cy - 0.01}`);
    group.appendChild(cir);
  }
  let linePts = []
  const lineInit = (x1, y1) => {
    linePts = []
    linePts.push([x1, y1])
  }

  const lineExtend = (x2, y2) => {
    if (linePts.length < 2) {
      lineCorner(x2, x2)
    }
    linePts[linePts.length - 1] = [x2, y2]
  }

  const lineCorner = (x2, y2) => {
    linePts.push([x2, y2])
  }

  const toSVG = (pt) => (`L${pt[0]} ${pt[1]}`)

  const lineComplete = (group) => {
    if (linePts.length < 1) return
    if (linePts.length < 2) return // addDot(group, linePts[0][0], linePts[0][1], 1)
    let line = document.createElementNS('http://www.w3.org/2000/svg', 'path')
    const firstPt = linePts.shift()
    line.setAttribute('d', `M${firstPt[0]} ${firstPt[1]} ${linePts.map(toSVG)}`);
    group.appendChild(line);
    linePts = []
  }

  const downloadSVG = () => {
    // since React will not do namespaced attributes (e.g. inkscape:label="0-Yellow"), so....
    svg = document.getElementsByTagName("svg")[0];
    svg.setAttribute("xmlns:inkscape", "http://www.inkscape.org/namespaces/inkscape");

    const svgtext = svg.outerHTML;
    if (svgtext) {
      const blob = new Blob([svgtext], { type: "image/svg+xml" });
      downloadBlob(blob, `dither_dots_${fileName}.svg`);
    }
  };
  function downloadBlob(blob, filename) {
    const objectUrl = URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.href = objectUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    setTimeout(() => URL.revokeObjectURL(objectUrl), 5000);
  }

  document.getElementById("download-svg").addEventListener("click", downloadSVG);

  const findFirst = (imArr, threshold, channel, xoff, yoff) => {
    let randomTries = 20
    while (randomTries) {
      randomTries--
      const x = Math.floor(Math.random() * (width - xoff))
      const y = Math.floor(Math.random() * (height - yoff))
      const i = getIndex(x + xoff, y + yoff)
      // console.log(i, x, y, channel, imArr.data[i + channel])
      if (imArr.data[i + channel] <= threshold) {
        return [x + xoff, y + yoff]
      }
    }
    // console.log("findFirst failed random")
    for (x = 0; x < width - xoff; x++) {
      for (y = 0; y < height - yoff; y++) {
        const i = getIndex(x + xoff, y + yoff)
        // if(x === 50 && y === 60) console.log("", i, x, y, channel)
        if (imArr.data[i + channel] <= threshold)
          return [x + xoff, y + xoff]
      }
    }
    // console.log("findFirst failed exaustive")
    return [-1, -1];
  }

  const alterDir = () => {
    const alteri = (Math.random() > 0.5) ? 0 : 1;
    if (dpos[alteri] === 0)
      dpos[alteri] = (Math.random() > 0.5) ? -1 : 1;
    else dpos[alteri] = 0
  }
  const inBounds = (x, y) => (x > 0 && y > 0 && x < width && y < height)
  const alterHoriz2 = () => {
    if (dpos[0] > 0 || dpos[0] < 0) {
      dpos[0] = 0
      dpos[1] = (Math.random() > 0.5) ? 1 : -1;
      return
    }
    if (dpos[1] > 0 || dpos[1] < 0) {
      dpos[0] = (Math.random() > 0.5) ? 1 : -1;
      dpos[1] = 0
      return
    }
    dpos[0] = 0;
    dpos[1] = (Math.random() > 0.5) ? 1 : -1;
  }
  const alterHoriz = () => {
    if (dpos[0] > 0) {
      dpos[0] = 0
      dpos[1] = 1
      return
    }
    if (dpos[0] < 0) {
      dpos[0] = 0
      dpos[1] = -1
      return
    }
    if (dpos[1] > 0) {
      dpos[1] = 0
      dpos[0] = -1
      return
    }
    if (dpos[1] < 0) {
      dpos[1] = 0
      dpos[0] = 1
      return
    }
  }

  const alterDiag = () => {
    if (dpos[0] >= 0 && dpos[1] >= 0) {
      dpos[0] = -1
      dpos[1] = 1
      return
    }
    if (dpos[0] <= 0 && dpos[1] >= 0) {
      dpos[0] = -1
      dpos[1] = -1
      return
    }
    if (dpos[0] <= 0 && dpos[1] <= 0) {
      dpos[0] = 1
      dpos[1] = -1
      return
    }
    if (dpos[0] >= 0 && dpos[1] <= 0) {
      dpos[0] = 1
      dpos[1] = 1
      return
    }
  }

  const findNext = (imArr, threshold, channel, xoff, yoff) => {
    let ableToFlow = 0
    while (ableToFlow < 12) {
      ableToFlow++
      // if (Math.random() > 0.95) {
      //  alterDir()
      // }
      let mpx = pos[0] + dpos[0] + xoff
      let mpy = pos[1] + dpos[1] + yoff
      const i = getIndex(mpx, mpy)
      if (inBounds(mpx, mpy) && imArr.data[i + channel] <= threshold) {
        return [mpx, mpy, (ableToFlow === 1)]
      }
      alterHoriz2()
      // alterDiag()
    }

    let neighbors = 0
    let lastX = 0
    let lastY = 0
    for (x = pos[0] - 1; x < pos[0] + 1; x++) {
      for (y = pos[1] - 1; y < pos[1] + 1; y++) {
        if (inBounds(x + xoff, y + yoff)) {
          const i = getIndex(x + xoff, y + yoff)
          if (imArr[i + channel] <= threshold) {
            neighbors++
            lastX = x + xoff
            lastY = y + yoff
          }
        }
      }
    }
    if (neighbors >= 1) return [lastX, lastY, false]
    penDown = false
    return [-1, -1, false]
  }

  const findaway = (imArr, threshold, stepsize, channel, scale, xoff, yoff) => {
    penDown = false
    keepGoing = true
    let rounds = 1000000
    while (keepGoing && rounds > 0) {
      rounds--
      if (penDown) {
        const [nx, ny, flow] = findNext(imArr, threshold, channel, xoff, yoff)
        if (nx < 0 || ny < 0) {
          lineComplete(svgGroup[channel])
          penDown = false
          // console.log("line done at", pos)
          continue
        }
        if (flow) {
          lineExtend(nx * scale, ny * scale)
        }
        else {
          lineCorner(nx * scale, ny * scale)
        }
        const i = getIndex(pos[0], pos[1])
        imArr.data[i + channel] = Math.min(255, imArr.data[i + channel] + stepsize)
        pos[0] = nx
        pos[1] = ny
      }
      else {
        const [fx, fy] = findFirst(imArr, threshold, channel, xoff, yoff)
        if (fx < 0 || fy < 0) {
          keepGoing = false
          break
        }
        lineInit(fx * scale, fy * scale)
        const i = getIndex(fx, fy)
        imArr.data[i + channel] = Math.min(255, imArr.data[i + channel] + stepsize)
        pos[0] = fx
        pos[1] = fy
        penDown = true
      }
    }
    console.log("unused rounds", rounds)
  }
</script>

</html>